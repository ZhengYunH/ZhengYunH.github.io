# 类反射实现

## 整体流程

在遁入具体的代码细节前，首先对整个类反射的流程进行宏观上的梳理。

1. 在编译流程中，UHT会分析代码生成 .generated.h 和.gen.cpp 文件

2. 当引擎启动，LoadModule时，通过自动生成的.gen.cpp中的静态变量`FCompiledInDefer`初始化，将Class的注册函数加入全局唯一的`DeferredCompiledInRegistration`数组中

3. 在同一时机，构造UClass对象的方法通过` TClassCompiledInDefer`收集到`DeferredClassRegistration`中

4. 每一个模块加载完毕后，都会调用`ProcessNewlyLoadedUObjects`去对Class对象进行注册，对`DeferredClassRegistration`和`DeferredCompiledInRegistration`中的每一个成员进行`Register`的调用。经过一系列的转发和初始化，最终会将生成的Class对象写入到GUObjectArray和FUObjectHashTables中

   ```c++
   FModuleManager::Get().OnProcessLoadedObjectsCallback().AddStatic(ProcessNewlyLoadedUObjects);
   ```

   `ProcessNewlyLoadedUObjects`会被调用很多次，之所以这样做，是因为模块有不同的加载时机，所以引擎中对UClass的构造也不是个一次性的过程。

## 代码生成

UHT生成的代码包括两部分 .generated.h 和 .gen.cpp，为了研究这两个文件中的内容，按最简化原则，将以下面代码作为示例进行分析。另外，以下分析中默认`WITH_HOTFIX`与`WITH_METADATA`。

```c++
// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "UObject/NoExportTypes.h"
#include "MyObject.generated.h"

/**
 * 
 */
UCLASS()
class PROJECT_API UMyObject : public UObject
{
	GENERATED_BODY()
	
public:
	UFUNCTION()
	void FuncTest();

	UPROPERTY()
	int PropTest;
};
```

先来看一下示例中几个宏所代表的含义。

### 宏展开

示例代码仅包含四个宏：`UCLASS`，`GENERATED_BODY`，`UFUNCTION`，`UPROPERTY`，下面将它们展开后观察每个宏具体所代表的含义。

#### UCLASS

```c++
#define BODY_MACRO_COMBINE_INNER(A,B,C,D) A##B##C##D
#define BODY_MACRO_COMBINE(A,B,C,D) BODY_MACRO_COMBINE_INNER(A,B,C,D)
#define UCLASS(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_PROLOG)
```

UCLASS的作用只是将几个参数按字符串的形式拼接在一起。对两个存在二次展开的参数进行解释：

+ `CURRENT_FILE_ID`：将在.generated.h中被定义。示例中展开后为 Project_Source_Project_MyObject_h
+ `__LINE__`：内置宏，代表该行代码所在的行号。示例中该值为12

示例中  `UCLASS()` 展开后变为 `Project_Source_Project_MyObject_h_12_PROLOG`

#### GENERATED_BODY

```c++
#define BODY_MACRO_COMBINE_INNER(A,B,C,D) A##B##C##D
#define BODY_MACRO_COMBINE(A,B,C,D) BODY_MACRO_COMBINE_INNER(A,B,C,D)
#define GENERATED_BODY(...) BODY_MACRO_COMBINE(CURRENT_FILE_ID,_,__LINE__,_GENERATED_BODY);
```

和UCLASS相同，只是拼接字符串。

示例中 ` GENERATED_BODY ` 展开后变为 `Project_Source_Project_MyObject_h_15_GENERATED_BODY`

#### UFUNCTION / UPROPERTY

```c++
#define UPROPERTY(...)
#define UFUNCTION(...)
```

这两个都是空宏，仅仅为UHT扫描信息提供标记。

#### **展开**

因此经过宏展开后，示例代码变为以下内容：

```c++
...
Project_Source_Project_MyObject_h_12_PROLOG		/* UCLASS() */
class PROJECT_API UMyObject : public UObject
{
	Project_Source_Project_MyObject_h_15_GENERATED_BODY		/* GENERATED_BODY() */

public:
	/* UFUNCTION() */
	void FuncTest();

	/* UPROPERTY() */
	int PropTest;
}
```

想要为UMyObject提供类型系统的支持，除了通过继承的方式 —— 在父类UObject提供的通用方法，还可以利用这两个展开后的宏注入所需内容。要搞清楚UMyObject如何支持类型系统，这两个展开的宏 `Project_Source_Project_MyObject_h_12_PROLOG` 和 `Project_Source_Project_MyObject_h_15_GENERATED_BODY` 至关重要。在`.generated.h` 中定义了这两个宏，接下来就来研究一下到底UHT在自动生成的`.generated.h`为我们准备了什么内容。

### .generated.h

在上文中，我们留下了三个宏没有解释，分别为`CURRENT_FILE_ID`, `Project_Source_Project_MyObject_h_12_PROLOG`和`Project_Source_Project_MyObject_h_15_GENERATED_BODY`。 首先明确上面这几个宏的具体含义。

```c++
...
#define Project_Source_Project_MyObject_h_12_PROLOG
...

#define Project_Source_Project_MyObject_h_15_GENERATED_BODY \
PRAGMA_DISABLE_DEPRECATION_WARNINGS \
public: \
	Project_Source_Project_MyObject_h_15_PRIVATE_PROPERTY_OFFSET \
	Project_Source_Project_MyObject_h_15_SPARSE_DATA \
	Project_Source_Project_MyObject_h_15_RPC_WRAPPERS_NO_PURE_DECLS \
	Project_Source_Project_MyObject_h_15_INCLASS_NO_PURE_DECLS \
	Project_Source_Project_MyObject_h_15_ENHANCED_CONSTRUCTORS \
private: \
PRAGMA_ENABLE_DEPRECATION_WARNINGS

...
#define CURRENT_FILE_ID Project_Source_Project_MyObject_h
```

最后一行的`CURRENT_FILE_ID`显而易见，利用当前头文件所在的目录位置，用`_`替代了`../`就可以得到这个展开：是为了保证了每一个生成文件中的宏在全局中是唯一的。 `*_PROLOG`在这里展开后还是空宏，暂时可以先不管。

来重点关注一下`*_GENERATED_BODY`展开的内容。

#### `*_GENERATED_BODY`

```c++
PRAGMA_DISABLE_DEPRECATION_WARNINGS // 屏蔽编译器warning
public:
    Project_Source_Project_MyObject_h_15_PRIVATE_PROPERTY_OFFSET // 空宏，暂时可以不关注
	Project_Source_Project_MyObject_h_15_SPARSE_DATA // 空宏，暂时可以不关注
	Project_Source_Project_MyObject_h_15_RPC_WRAPPERS_NO_PURE_DECLS
	Project_Source_Project_MyObject_h_15_INCLASS_NO_PURE_DECLS
	Project_Source_Project_MyObject_h_15_ENHANCED_CONSTRUCTORS
private:
PRAGMA_ENABLE_DEPRECATION_WARNINGS // 启用编译器warning
```

对于`*_PRIVATE_PROPERTY_OFFSET`和`_SPARSE_DATA`在这里可以暂时先不关注，具体会在 ***属性反射实现*** 中解释。对于另外三个宏需要详细展开，对照着示例代码进行分析。

```c++
UCLASS()
class PROJECT_API UMyObject : public UObject
{
	GENERATED_BODY()
	
public:
	UFUNCTION()
	void FuncTest();

	UPROPERTY()
	int PropTest;
};
```

##### `*_RPC_WRAPPERS_NO_PURE_DECLS`

```c++
#define Project_Source_Project_MyObject_h_15_RPC_WRAPPERS_NO_PURE_DECLS \
 \
	DECLARE_FUNCTION(execFuncTest);

// Runtime\CoreUObject\Public\UObject\ObjectMacros.h
// This macro is used to declare a thunk function in autogenerated boilerplate code
#define DECLARE_FUNCTION(func) static void func( UObject* Context, FFrame& Stack, RESULT_DECL )
```

这个宏展开后，提供了与`FuncTest`相关的静态函数：`execFuncTest`。在这里我们只需要知道，这种被生成的`exec<FuncName>`被称为trunk函数，具体作用将会在 [函数反射实现](函数反射实现.md) 中进行解释。

##### `*_INCLASS_NO_PURE_DECLS`

```c++
#define Project_Source_Project_MyObject_h_15_INCLASS_NO_PURE_DECLS \
private: \
	static void StaticRegisterNativesUMyObject(); \
	friend struct Z_Construct_UClass_UMyObject_Statics; \
public: \
	DECLARE_CLASS(UMyObject, UObject, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT("/Script/Project"), NO_API) \
	DECLARE_SERIALIZER(UMyObject)
```

+ 声明`StaticRegisterNativesUMyObject`，作用是将trunk函数注册到UClass，他的定义将在`.gen.cpp`中描述。

+ 标记`Z_Construct_UClass_UMyObject_Statics`为友元，相关定义在`.gen.cpp`中描述
+ `DECLARE_CLASS`的定义比较复杂，也是整个头文件的重点。下面详细描述
+ `DECLARE_SERIALIZER`重载了序列化相关的操作符`<<`

###### DECLARE_CLASS

```c++
/* DECLARE_CLASS(UMyObject, UObject, COMPILED_IN_FLAGS(0), CASTCLASS_None, TEXT("/Script/Project"), NO_API) */

#define DECLARE_CLASS( TClass, TSuperClass, TStaticFlags, TStaticCastFlags, TPackage, TRequiredAPI  ) \
private: \
    TClass& operator=(TClass&&);   \
    TClass& operator=(const TClass&);   \
	TRequiredAPI static UClass* GetPrivateStaticClass(); \
public: \
	/** Bitwise union of #EClassFlags pertaining to this class.*/ \
	enum {StaticClassFlags=TStaticFlags}; \
	/** Typedef for the base class ({{ typedef-type }}) */ \
	typedef TSuperClass Super;\
	/** Typedef for {{ typedef-type }}. */ \
	typedef TClass ThisClass;\
	/** Returns a UClass object representing this class at runtime */ \
	inline static UClass* StaticClass() \
	{ \
		return GetPrivateStaticClass(); \
	} \
	/** Returns the package this class belongs in */ \
	inline static const TCHAR* StaticPackage() \
	{ \
		return TPackage; \
	} \
	/** Returns the static cast flags for this class */ \
	inline static EClassCastFlags StaticClassCastFlags() \
	{ \
		return TStaticCastFlags; \
	} \
	/** For internal use only; use StaticConstructObject() to create new objects. */ \
	inline void* operator new(const size_t InSize, EInternal InInternalOnly, UObject* InOuter = (UObject*)GetTransientPackage(), FName InName = NAME_None, EObjectFlags InSetFlags = RF_NoFlags) \
	{ \
		return StaticAllocateObject(StaticClass(), InOuter, InName, InSetFlags); \
	} \
	/** For internal use only; use StaticConstructObject() to create new objects. */ \
	inline void* operator new( const size_t InSize, EInternal* InMem ) \
	{ \
		return (void*)InMem; \
	}
```

+ 屏蔽 赋值运算符，移动赋值运算符
+ 声明`GetPrivateStaticClass`，作用是生成真正的UClass对象，将在`.gen.cpp`中被定义
+ 记录`EClassFlags`属性的`StaticClassFlags`
+ 提供 `Super`， `ThisClass`的语法糖
+ 返回UClass对象的`StaticClass`
+ 返回常量的函数`StaticPackage`，`StaticClassCastFlags`
+ 提供 `new` 操作符

###### 小结

上面的内容有些杂乱，总结一下：经过`*_INCLASS_NO_PURE_DECLS`的宏展开，我们为UMyObject注入了什么内容呢？

+ 声明
  + `StaticRegisterNativesUMyObject`：注册trunk函数到UClass中
  + `GetPrivateStaticClass`：获取UClass对象，也是生成UClass对象的位置
  + `Z_Construct_UClass_UMyObject_Statics`为友元
+ 重载
  + 序列化操作符`<<`
  + 操作符`new`
  + 屏蔽**赋值运算符**，**移动赋值运算符**
+ 定义
  +  `Super`， `ThisClass`的语法糖
  + 记录`EClassFlags`属性的`StaticClassFlags`
  + 返回常量的函数`StaticPackage`，`StaticClassCastFlags`
  + 返回UClass对象的`StaticClass`

##### `*_ENHANCED_CONSTRUCTORS`

```c++
#define Project_Source_Project_MyObject_h_15_ENHANCED_CONSTRUCTORS \
	/** Standard constructor, called after all reflected properties have been initialized */ \
	NO_API UMyObject(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get()) : Super(ObjectInitializer) { }; \
private: \
	/** Private move- and copy-constructors, should never be used */ \
	NO_API UMyObject(UMyObject&&); \
	NO_API UMyObject(const UMyObject&); \
public: \
	DECLARE_VTABLE_PTR_HELPER_CTOR(NO_API, UMyObject); \
	DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(UMyObject); \
	DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(UMyObject)
    
// Runtime\CoreUObject\Public\UObject\ObjectMacros.h
#define DECLARE_VTABLE_PTR_HELPER_CTOR(API, TClass) \
	API TClass(FVTableHelper& Helper);

#define DEFINE_VTABLE_PTR_HELPER_CTOR_CALLER(TClass) \
static UObject* __VTableCtorCaller(FVTableHelper& Helper) \
{ \
	return new (EC_InternalUseOnlyConstructor, (UObject*)GetTransientPackage(), NAME_None, RF_NeedLoad | RF_ClassDefaultObject | RF_TagGarbageTemp) TClass(Helper); \
}

#define DEFINE_DEFAULT_OBJECT_INITIALIZER_CONSTRUCTOR_CALL(TClass) \
	static void __DefaultConstructor(const FObjectInitializer& X) { new((EInternal*)X.GetObj())TClass(X); }
```

+ 提供标准的构造函数，用于新对象的生成
+ 屏蔽移动和拷贝构造函数
+ 提供支持蓝图的构造函数
+ 提供默认Object的构造函数

这个宏展开提供了不同类型的构造函数，具体构造函数的含义暂时可不深究。

#### 小结

分析完三个宏的含义，除此之外，在整个.generated.h文件中，还剩下`template<> PROJECT_API UClass* StaticClass<*class* UMyObject>()`没谈及。这里只是对`template<typename ClassType> StaticClass()`做了个特化声明，真正的定义将在`.gen.cpp`中解开面纱。

在.generated.h定义的几个宏为UMyObject类注入了不少类型系统所需要的方法，但实际上只为UMyObject注入了唯一的属性StaticClassFlags，甚至只是个类似static的成员，对于生成的对象而言是不会产生多余的内存开销。

### .gen.cpp

```c++
// Cross Module References
...
// End Cross Module References
DEFINE_FUNCTION(UMyObject::execFuncTest)
{
    ...
}
void UMyObject::StaticRegisterNativesUMyObject()
{
   ...
}
struct Z_Construct_UFunction_UMyObject_FuncTest_Statics
{
    ...
}
UFunction* Z_Construct_UFunction_UMyObject_FuncTest()
{
    ...
}
UClass* Z_Construct_UClass_UMyObject_NoRegister()
{
	return UMyObject::StaticClass();
}
struct Z_Construct_UClass_UMyObject_Statics
{
    ...
}
const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_UMyObject_Statics::Class_MetaDataParams[] = {
	{ "Comment", "/**\n * \n */" },
	{ "IncludePath", "MyObject.h" },
	{ "ModuleRelativePath", "MyObject.h" },
};
const UE4CodeGen_Private::FMetaDataPairParam Z_Construct_UClass_UMyObject_Statics::NewProp_PropTest_MetaData[] = {...};
const UE4CodeGen_Private::FUnsizedIntPropertyParams Z_Construct_UClass_UMyObject_Statics::NewProp_PropTest = {...};
const UE4CodeGen_Private::FPropertyParamsBase* const Z_Construct_UClass_UMyObject_Statics::PropPointers[] = {...};

const FCppClassTypeInfoStatic Z_Construct_UClass_UMyObject_Statics::StaticCppClassTypeInfo = {
	TCppClassTypeTraits<UMyObject>::IsAbstract,
};
const UE4CodeGen_Private::FClassParams Z_Construct_UClass_UMyObject_Statics::ClassParams = {...};
UClass* Z_Construct_UClass_UMyObject()
{
	static UClass* OuterClass = nullptr;
	if (!OuterClass)
	{
		UE4CodeGen_Private::ConstructUClass(OuterClass, Z_Construct_UClass_UMyObject_Statics::ClassParams);
	}
	return OuterClass;
}
IMPLEMENT_CLASS(UMyObject, 1704144988);
template<> PROJECT_API UClass* StaticClass<UMyObject>()
{
	return UMyObject::StaticClass();
}
static FCompiledInDefer Z_CompiledInDefer_UClass_UMyObject(Z_Construct_UClass_UMyObject, &UMyObject::StaticClass, TEXT("/Script/Project"), TEXT("UMyObject"), false, nullptr, nullptr, nullptr);
DEFINE_VTABLE_PTR_HELPER_CTOR(UMyObject);
```

.gen.cpp中包含了许多内容，简单概括包括三个相关部分：

+ Function
+ Property
+ Class

对于Function和Property的反射生成内容在此不展开讨论，会在后面相关的 [函数反射实现](函数反射实现.md)  和 [属性反射实现](属性反射实现.md) 中进行详细描述，重点关注Class相关的部分。

还记得我们在 .generated.h 中提及，UMyObject将 `Z_Construct_UClass_UMyObject_Statics` 标记为了友元，这个结构体真正定义的地方在 .gen.cpp，也就是当前描述的这个文件中。这个结构体也是分析类反射实现的关键，首先我们对这个结构体进行单独讨论。

#### `Z_Construct_UClass_<ClassName>_Statics` 

```c++
struct Z_Construct_UClass_UMyObject_Statics
{
    static UObject* (*const DependentSingletons[])();	// 依赖对象，也就是继承关系
    static const FClassFunctionLinkInfo FuncInfo[];	// 方法相关信息
    static const UE4CodeGen_Private::FMetaDataPairParam Class_MetaDataParams[]; // 类Meta相关信息
    static const UE4CodeGen_Private::FMetaDataPairParam NewProp_PropTest_MetaData[]; // 属性Meta相关信息
    static const UE4CodeGen_Private::FUnsizedIntPropertyParams NewProp_PropTest; // 属性
    static const UE4CodeGen_Private::FPropertyParamsBase* const PropPointers[]; // 所有属性集合
    static const FCppClassTypeInfoStatic StaticCppClassTypeInfo;	// 标记Class是否为抽象类
    static const UE4CodeGen_Private::FClassParams ClassParams;	// 创建出UClass对象所需要的所有参数
};
```

整个.gen.cpp中基本是围绕着这个结构体展开的，从结构体的成员名字中，除了`StaticCppClassTypeInfo` 和 `ClassParams` 外，不难猜出他们的含义，其中具体的内容会在不同的章节中进行描述，在此我们仅需要关注 `ClassParams` 。

##### ClassParams

ClassParams描述的是创建出UClass对象所需要的所有参数，而创建出来的UClass对象是类型系统的关键。

要真正理解UE4的类反射实现，首先思考，什么数据是类型系统所需要的，或者说我们需要什么数据才能使类型系统运转起来：

+ 名字
+ 类属性：Public / Private ..
+ 组合对象：父对象Outer
+ 继承关系：父类、接口
+ 函数成员：Functions
+ 属性成员：Propertys
+ 特殊Flag：标记Editable，BluePrintType

**FClassParams**

想明白了上面的问题，再来看`ClassParams`的类型`FClassParams`中包含什么具体的参数，一一对照着上面所需的数据，不难理解其中大部分的数据。

```c++
// Runtime\CoreUObject\Public\UObject\UObjectGlobals.h
struct FClassParams
{
	UClass*                                   (*ClassNoRegisterFunc)(); // NoRegister构造函数，返回StaticClass()
	const char*                                 ClassConfigNameUTF8; // 该类的配置名称，当该类被表示为config=ConfigName时有值
	const FCppClassTypeInfoStatic*              CppClassInfo;	// 类属性 Abstract，见FCppClassTypeInfoStatic定义
	UObject*                           (*const *DependencySingletonFuncArray)(); // 继承关系父类
	const FClassFunctionLinkInfo*               FunctionLinkArray; // 函数成员Functions
	const FPropertyParamsBase* const*           PropertyArray;	// 属性成员Propertys
	const FImplementedInterfaceParams*          ImplementedInterfaceArray; // 继承关系Interface
	int32                                       NumDependencySingletons;
	int32                                       NumFunctions;
	int32                                       NumProperties;
	int32                                       NumImplementedInterfaces;
	uint32                                      ClassFlags; // 特殊Flag：EClassFlags，见EClassFlags定义
#if WITH_METADATA
	const FMetaDataPairParam*                   MetaDataArray;  // 特殊Flag：BlueprintType标记之类的
	int32                                       NumMetaData;
#endif
};
```

>  **FCppClassTypeInfoStatic**
>
> ```c++
> // Runtime\CoreUObject\Public\UObject\Class.h
> struct FCppClassTypeInfoStatic
> {
> 	bool bIsAbstract;  // __is_abstract(T)，判断Type是否为虚类
> };
> ```
>
> FCppClassTypeInfoStatic中只有一个bool变量成员，追根溯源可以发现它最终表示的含义是：当前类是否为抽象类（abstract class）。

> **EClassFlags**
>
> 描述了Class的特殊Flag
>
> ```c++
> // Runtime\CoreUObject\Public\UObject\ObjectMacros.h
> 
> enum EClassFlags
> {
>     /** No Flags */
> 	CLASS_None				  = 0x00000000u,
> 	/** Class is abstract and can't be instantiated directly. */
> 	CLASS_Abstract            = 0x00000001u,
>     ...
>     /** */
> 	CLASS_MatchedSerializers  = 0x00000020u,
> 	...
> 	/** Class is a native class - native interfaces will have CLASS_Native set, but not RF_MarkAsNative */
> 	CLASS_Native			  = 0x00000080u,
>     ...
>     /** Indicates this class must be DLL exported/imported (along with all of it's members) */
> 	CLASS_RequiredAPI	      = 0x00100000u,
>     ...
> }
> 
> // 例如UMyObject中传入的0x001000A0u: CLASS_RequiredAPI | CLASS_Native | CLASS_MatchedSerializers
> ```
>
> EClassFlags有很多，可以对照着生成代码中传入的参数对照着看。

`ClassParams`记录了一些元数据，也就是这个结构体存储了创建UClass对象所需要的信息，我们只要在某个合适的时机利用其中的信息去构造一个真正的UClass对象。

.gen.cpp 中除了ClassParams的相关内容，剩下的代码就不多了，只剩下以下内容。我们先讨论`IMPLEMENT_CLASS`，然后再来讨论`Z_CompiledInDefer_UClass_UMyObject`。至于`DEFINE_VTABLE_PTR_HELPER_CTOR`，只是对头文件中`DECLARE_VTABLE_PTR_HELPER_CTOR`的简单定义，可参考 ObjectMacro.h 。

```c++
UClass* Z_Construct_UClass_UMyObject()
{
	static UClass* OuterClass = nullptr;
	if (!OuterClass)
	{
		UE4CodeGen_Private::ConstructUClass(OuterClass, Z_Construct_UClass_UMyObject_Statics::ClassParams);
	}
	return OuterClass;
}
IMPLEMENT_CLASS(UMyObject, 1704144988);
template<> PROJECT_API UClass* StaticClass<UMyObject>()
{
	return UMyObject::StaticClass();
}
static FCompiledInDefer Z_CompiledInDefer_UClass_UMyObject(Z_Construct_UClass_UMyObject, &UMyObject::StaticClass, TEXT("/Script/Project"), TEXT("UMyObject"), false, nullptr, nullptr, nullptr);
DEFINE_VTABLE_PTR_HELPER_CTOR(UMyObject);
```

#### IMPLEMENT_CLASS

```c++
#define IMPLEMENT_CLASS(TClass, TClassCrc) \
	static TClassCompiledInDefer<TClass> AutoInitialize##TClass(TEXT(#TClass), sizeof(TClass), TClassCrc); \
	UClass* TClass::GetPrivateStaticClass() \
	{ \
		static UClass* PrivateStaticClass = NULL; \
		if (!PrivateStaticClass) \
		{ \
			/* this could be handled with templates, but we want it external to avoid code bloat */ \
			GetPrivateStaticClassBody( \
				StaticPackage(), \
				(TCHAR*)TEXT(#TClass) + 1 + ((StaticClassFlags & CLASS_Deprecated) ? 11 : 0), \
				PrivateStaticClass, \
				StaticRegisterNatives##TClass, \
				sizeof(TClass), \
				alignof(TClass), \
				(EClassFlags)TClass::StaticClassFlags, \
				TClass::StaticClassCastFlags(), \
				TClass::StaticConfigName(), \
				(UClass::ClassConstructorType)InternalConstructor<TClass>, \
				(UClass::ClassVTableHelperCtorCallerType)InternalVTableHelperCtorCaller<TClass>, \
				&TClass::AddReferencedObjects, \
				&TClass::Super::StaticClass, \
				&TClass::WithinClass::StaticClass \
			); \
		} \
		return PrivateStaticClass; \
	}
```

这个宏展开主要包括两块内容：`GetPrivateStaticClass` 和 `AutoInitialize##TClass`

##### GetPrivateStaticClassBody

对于GetPrivateStaticClass可以看到，是个延迟初始化的经典操作，我们只需要关注真正执行初始化的方法`GetPrivateStaticClassBody`。

```c++
COREUOBJECT_API void GetPrivateStaticClassBody(
	const TCHAR* PackageName,	// Name of the package this class will be inside
	const TCHAR* Name,	// Name of the class
	UClass*& ReturnClass,	// ReturnClass reference to pointer to result. This must be PrivateStaticClass.
	void(*RegisterNativeFunc)(),	// Native function registration function pointer.
	uint32 InSize,	// Size of the class
	uint32 InAlignment,	// Alignment of the class
	EClassFlags InClassFlags,	// Class flags
	EClassCastFlags InClassCastFlags,	// Class cast flags
	const TCHAR* InConfigName,	// Class config name
	UClass::ClassConstructorType InClassConstructor, // Class constructor function pointer
	UClass::ClassVTableHelperCtorCallerType InClassVTableHelperCtorCaller,	// Class constructor function for vtable pointer
	UClass::ClassAddReferencedObjectsType InClassAddReferencedObjects,	//  Class AddReferencedObjects function pointer
	UClass::StaticClassFunctionType InSuperClassFn,	// Super class function pointer
	UClass::StaticClassFunctionType InWithinClassFn, // Within class
	bool bIsDynamic = false,	// true if the class can be constructed dynamically at runtime
	UDynamicClass::DynamicClassInitializerType InDynamicClassInitializer = nullptr)
{
    ReturnClass = (UClass*)GUObjectAllocator.AllocateUObject(sizeof(UClass), alignof(UClass), true);
    ReturnClass = ::new (ReturnClass)
        UClass
        (
            EC_StaticConstructor,
            Name,
            InSize,
            InAlignment,
            InClassFlags,
            InClassCastFlags,
            InConfigName,
            EObjectFlags(RF_Public | RF_Standalone | RF_Transient | RF_MarkAsNative | RF_MarkAsRootSet),
            InClassConstructor,
            InClassVTableHelperCtorCaller,
            InClassAddReferencedObjects
        );
    InitializePrivateStaticClass(
		InSuperClassFn(),
		ReturnClass,
		InWithinClassFn(),
		PackageName,
		Name
		);

	// Register the class's native functions.
	RegisterNativeFunc();
}
```

申请空间，构造UClass，建立关系（父子关系，注册），函数注册，一气呵成。

##### TClassCompiledInDefer 

对于`AutoInitialize##TClass`，来一下他的类型 TClassCompiledInDefer

```c++
template <typename TClass>
struct TClassCompiledInDefer : public FFieldCompiledInInfo
{
	TClassCompiledInDefer(const TCHAR* InName, SIZE_T InClassSize, uint32 InCrc)
	: FFieldCompiledInInfo(InClassSize, InCrc)
	{
		UClassCompiledInDefer(this, InName, InClassSize, InCrc);
	}
	virtual UClass* Register() const override
	{
        LLM_SCOPE(ELLMTag::UObject);
		return TClass::StaticClass();
	}
	virtual const TCHAR* ClassPackage() const override
	{
		return TClass::StaticPackage();
	}
};

void UClassCompiledInDefer(FFieldCompiledInInfo* ClassInfo, const TCHAR* Name, SIZE_T ClassSize, uint32 Crc)
{
#if WITH_HOT_RELOAD
    ...
#endif     
	GetDeferredClassRegistration().Add(ClassInfo);
}
```

又是一个经典的static初始化注册手段，利用静态变量在main前初始化的特性，在LoadModule时，会调用`TClassCompiledInDefer::TClassCompiledInDefer`，巧妙地将信息加入到`DeferredClassRegistration`中。

接下来看看换汤不换药的`Z_CompiledInDefer_UClass_UMyObject`。

#### FCompiledInDefer

```c++
/*
	static FCompiledInDefer Z_CompiledInDefer_UClass_UMyObject(Z_Construct_UClass_UMyObject, &UMyObject::StaticClass, TEXT("/Script/Project"), TEXT("UMyObject"), false, nullptr, nullptr, nullptr);
*/
struct FCompiledInDefer
{
	FCompiledInDefer(class UClass *(*InRegister)(), class UClass *(*InStaticClass)(), const TCHAR* PackageName, const TCHAR* Name, bool bDynamic, const TCHAR* DynamicPackageName = nullptr, const TCHAR* DynamicPathName = nullptr, void (*InInitSearchableValues)(TMap<FName, FName>&) = nullptr)
	{
		if (bDynamic)
		{
			GetConvertedDynamicPackageNameToTypeName().Add(FName(DynamicPackageName), FName(Name));
		}
		UObjectCompiledInDefer(InRegister, InStaticClass, Name, PackageName, bDynamic, DynamicPathName, InInitSearchableValues);
	}
};
```

同样的，直接看`Z_CompiledInDefer_UClass_UMyObject`的类型`FCompiledInDefer`，在构造函数中将注册函数传入到全局的`DeferredCompiledInRegistration`数组中。

#### 小结

在`IMPLEMENT_CLASS` 和`Z_CompiledInDefer_UClass_UMyObject`，我们发现了三个不同的注册过程，在这里对他们进行对比：

1. GetPrivateStaticClassBody中InitializePrivateStaticClass：继承父类的ClassFlags和ClassCastFlags
2. static TClassCompiledInDefer AutoInitialize##TClass：仅仅只是调用 `TClass::StaticClass();`，但该调用会构造真正的UClass
3. static FCompiledInDefer Z_CompiledInDefer_UClass_##TClass：将UClass对象写入到GUObjectArray和FUObjectHashTables中

这里可能会对2、3产生疑惑，TClassCompiledInDefer 和 FCompiledInDefer 是一一对应的，为什么一定要分成两个静态对象，分别进行注册，何不合二为一？这是因为TClassCompiledInDefer注册的过程是将Class对象生成出来，而FCompiledInDefer才会真正的将其加入到UE的对象管理中。

还有一个问题值得提出，为什么都是利用延迟注册，而不是直接在static函数中执行？这是为了对程序提供一些优化手段，UE4存在大量的类，如果都在static中直接执行相关的操作，那得等好一会才能进入到main中。所以只将这些信息注册，等到后面分帧也罢，多线程也好，总有手段去减少卡断，提高使用体验。

## 总结

由于类反射实现相对较为复杂，本文内容较多，后面考虑拆分成不同的章节。但要理解整个类反射地实现，弄明白反射的实现需要什么方法属性、在什么地方放置实现这些方法比较合理，再加上清晰地理解整个加载和初始化的过程，一切UE4中的代码行为就显得合理了。