# 操作符重载  
## 概述  
+ 对已有操作符进行重载，使得它们能对自定义类型的对象进行操作
+ 操作符重载也是一种[多态]()

### 基本原则
+ 只能对已有操作符进行重载
+ 不可以重载的操作符 `"." , '.*' , "?:" , "::" , "sizeof" `
+ 遵循已有操作符的语法
    * 不能改变操作数的个数
    * 不改变原操作符的优先级和结合性
### 方式
+ 重载成员函数
```
Complex operator + (const Complex &x) const{
    Complex temp;
    temp.real=real+x.real;
    temp.imag=imag+x.imag;
    return temp;
}
```
+ 包含（类型，结构，枚举或者他们的引用类型）的全局函数
```
Complex operator + (const Complex &c1,const Complex &c2){
    Complex temp;
    temp.real=real+x.real;
    temp.imag=imag+x.imag;
    return temp;
}
```

### 实现复数的"等于"和"不等于"操作
```
class Complex{
    double real,imag;
public:
    bool operator == (const Complex& x) const{
        return (real==x.real) && (imag == x.imag);
    }
    bool operator != (const Complex& x) const{
        return !(*this=x);
    }
}
```
## 双目操作符重载
### 定义
`<返回值类型> operator +(<类型> <参数>)`
### 使用
`a+b`
###例子
```
Complex operator +(const Complex& c){
    Complex temp;
    temp.real= c.real + this.real;
    temp.imag= c.imag + this.imag;
    return temp;
}
```
## 单目操作符重载
### 定义
`<返回值类型> operator #();`
### 使用
`#a`
### 例子
```
Complex operator -(){
    Complex temp;
    temp.real= -this.real;
    temp.imag= -this.imag;
    return temp;
}
```

## 特殊操作符的重载
### `++` 和 `--`的重载  
带有副作用的操作符，除了得到结果，还会改变操作数的值。  
#### 讨论 `++` 与 `--` 
```
int x=0;
++x;x++; //OK
++(++x);(++x)++;//OK 
++(x++);(x++)++;//Error
```

其中`++x`为[左值表达式](),`x++`为[右值表达式]()  
换一种说法，`++x` 与 `x` 使用同一内存单元，`x++` 另外开辟一块内存  

#### 重载
+ 重载`++(--)`时，如果没有特殊处理，他们的后置用法和前置用法公用同一个重载函数  
+ 为了区分前置后置，会加上一个一般用不到的`(int)`来实现后置`++`的重载函数
```
//前置的++重载函数
Counter &operator ++(){
    value++;
    return *this;
}

//后置的++重载函数
const Counter operator ++(int){
    Counter temp=*this;
    value++;    //写成++(*this);更好
    return temp;
}
```
---
### `=`的重载  
隐式赋值操作：对成员进行逐个复制  
```
class A
{
    int x,y;
    char *p;
    A& operator = (const A& x2){
        if(&x2 == this) return *this;
        delete []p;
        p=new char [strlen(x2.p)+1];
        strcpy(p,str);
        x=x2.x;
        y=x2.y;
        return *this;
    }
}
```
__思考题：__

+ 为什么要`A& operator...` 而不是`A operator...`?
    * 为了满足如下的操作
        - `c=(a=b)`
        - `(a=b)=c`
+ 为什么要返回`*this`?
    * 理由同上
+ `(const A& a2)`除了节约内存还有别的作用?
    * `if(&x2 == this) return *this;` 中需要用到a2的地址

#### 拷贝构造函数 和 `=`符号
+ 一般来说，自定义拷贝构造函数也需要自定义赋值操作符重载函数
+ 拷贝构造函数：`A b=a`，推荐使用`A b(a)`来调用拷贝构造函数以减少`=`的歧义
+ 赋值：`b=a`  
---
### `[]`的重载  
对于具有线性关系的元素构成的对象，可以通过重载`[]`实现对元素的访问  
```
class Vector
{
    int *p_data;
    int num;
public:
    int &operator[](int i){
        if( i<0 || i >=num) exit(-1);//需要异常处理
        return p_data[i];
    }
}

Vector v(10);
v[2];//访问向量的第三个元素
```
__思考题:__

+ 为何不直接用数组代替向量?
    * 自己实现类的优势是可以做额外的检查工作，直接使用数组不会检查越界
+ 为何 C 和 C++ 不检查数组越界?
    * 如果每个访问数组的地方都进行数组越界检查，开销会急剧增大
    * 没有必要检查，程序如果正确运行了，必然不会出现数组越界
+ 如何利用`[]`重载获得 `Matrix[i][j]`
```
class Matrix
{
    Vector *p_data;
    int row,col;
public:
    Matrix(int i,int c){}
    ~Matrix(){}
    Vector &operator[](int i){
        return p_data[i];
    }
}

Matrix m(10,20);
m[2][3]...
```
---
### `new` 和 `delete` 的重载
#### 讨论`new`和`delete`
+ `new`的功能:
    * 为动态对象分配空间
    * 调用对象类的构造构造函数
+ `delete`的功能:
    * 抵用对象类的析构函数
    * 释放动态对象的空间
+ 重载操作符 `new` 和 `delete` 时，重载的是它们分配空间和释放空间的功能，不影响对构造函数和析构函数的调用
#### `new`的重载  
`new`必须作为静态的成员函数来重载(static可写可不写)  
##### 格式
`void *operator new (size_t size);`  
+ 返回值类型必须为`void *`
+ 参数表示对象需要的空间大小，其类型为`size_t`

##### 例子
```
#include <cstring>
class A
{
    int x,y;
public:
    void *operator new(size_t size){
        void *p=malloc(size);
        memset(p,0,size);
        return p;
    }
}

A *q;
//编译程序自动计算size的大小
q = new A;
```

重载new时，可以带有别的参数
```
void *operator new(size_t size,...)
p = new (...) A(***);   //...是new的参数，***是A构造函数的参数

class A
{
public:
    A(int i){}
    void *operator new(size_t size,void *p){
        return p;
    }
}

char buf[sizeof(A)];
A *p=new(buf) A(0);
p->~A();    //不能调用系统的delete
```

__思考题__

+ 上述例子和默认的构造函数有何区别?
    * 为一个没有定义任何构造函数的类的对象提供初始化
+ 为什么会有默认构造函数?
+ 

## Remark  
+ 如何决定把一个操作符重载为类成员函数还是全局名字空间的成员
    * 如果一个重载操作符是类成员，那么只有当与他一起使用的左操作数是该类的对象时，该操作符才会被调用。如果该操作符的左操作数必须是其他的类型，则操作符必须被重载为全局名字空间的成员。
    * C++要求赋值=，下标[]，调用()， 和成员指向-> 操作符必须被定义为类成员操作符。任何把这些操作符定义为名字空间成员的定义都会被标记为编译时刻错误。
    * 如果有一个操作数是类类型如string类的情形那么对于对称操作符比如等于操作符最好定义为全局名字空间成员  
    
+ 重载操操作符首先要确定它的返回值是左值，还是右值，如果是左值最返回引用，如果是右值那就直接返回值
+ 因为强制转换是针对基本数据类型的，所以对类类型的转换需自定义
+ 转换运行符重载 
    + 声明形式：operator 类型名();它没有返回类型  
    + 对于转换运算符，还有一个需要注意的地方就是，如果A类中有以B为参数的转换函数（构造函数），那B中不能有A的转换运算符，不然就存在转换的二义性

```
class B{
    operator A(){}    
}
B b;
A(b);//A(b)有就可能是A的构造函数，也可以是B的转换运算符
```


